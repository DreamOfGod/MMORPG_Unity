1、临界区：进入访问共享资源的代码段前先获取临界区，离开访问共享资源的代码段后释放临界区
用于实现访问同一资源的代码段的互斥访问，同一时刻只有一个线程执行相关临界区代码，且只有该线程释放临界区，其它线程才能竞争临界区

无法控制线程的执行顺序，多个线程竞争临界区，优胜者先执行。取决于操作系统调度

Monitor类就是临界区，效率较Mutex类高。lock关键字和Monitor等价

2、互斥对象：类似于临界区，实现线程访问临界资源的互斥，但是属于内核对象，开销较大。可以跨进程

Mutex类就是互斥对象

3、信号量：相当于控制线程按照某种次序执行的一个计数值。当线程A需要线程B的计算结果时，它实际上是等待线程B计算完成后将计数器加1
信号量用于同步线程，控制线程的相对执行顺序。而临界区是用于实现对共享资源的互斥访问，需要仔细区分

信号量是内核对象，开销较大。可以跨进程

Semaphore类就是信号量

4、事件对象：控制线程等待其它线程触发事件，事件触发后，事件对象处于有信号状态。线程A在事件对象上等待，线程B触发事件，线程A解除等待。
事件对象分为手动重置事件和自动重置事件

自动重置事件：触发事件，在较短时间解除一个等待线程，并立即将事件对象重置为无信号状态。适合用来控制对共享资源的互斥访问。

手动重置事件：触发事件，会在较短时间内解除所有等待的线程，事件对象一直保持有信号状态，直到手动重置为无信号。如果在解除所有等待线程之前手动重置了，那么剩余线程将不会解除等待。
适合用来同步多个线程等待某个线程的计算结果

解除等待线程所需的具体时间，以及哪些等待线程会解除是随机的，取决于操作系统调度等因素，代码逻辑不能指望立即解除所有等待的线程

5、死锁：一组线程中，每个线程都因为请求已被其它线程占有的资源的锁而进入等待，没有一个线程能够解除已占有的资源的锁，造成所有线程都无法继续执行，被锁死了

死锁的四个必要条件：
（1）互斥条件：资源在一段时间内只能由一个进程使用
（2）请求和保持条件：进程已经占有至少一个资源，且又请求占有另一资源，而该资源已被其它线程占有，因此进程阻塞，且不释放已占有的进程
（3）不剥夺条件：进程占有的资源不能被剥夺，只有由占有的进程自己释放
（4）环路等待条件：存在进程-资源的环形依赖链，即一组进程{P0, P1, ..., Pn}中，P0等待P1占有的资源，P1等待P2占有的资源，，，，Pn等待P0占有的资源

预防死锁：破坏死锁的四个必要条件中的一个或多个，即可预防死锁。其中，互斥条件和不剥夺条件基本无法改变，因此主要是破坏请求和保持条件、环路等待条件
（1）破坏请求和保持条件：当进程占有某个资源后，又申请另一资源却无法立即获得，此时进程释放原本占有的资源
（2）破坏环路等待条件：对资源编号，所有进程按照升序的顺序申请资源，即可避免环路等待




